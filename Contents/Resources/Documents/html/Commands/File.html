<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta name=generator content="nsis-docset-builder v0.6.0"><title>File</title><style>@font-face{font-family:'Fira Sans';src:url(../../fonts/FiraSans-Light.eot);src:local('Fira Sans Light'),url(../../fonts/FiraSans-Light.eot) format('embedded-opentype'),url(../../fonts/FiraSans-Light.woff2) format('woff2'),url(../../fonts/FiraSans-Light.ttf) format('truetype');font-weight:300;font-style:normal;font-display:swap}@font-face{font-family:'Fira Sans';src:url(../../fonts/FiraSans-Regular.eot);src:local('Fira Sans Regular'),url(../../fonts/FiraSans-Regular.eot) format('embedded-opentype'),url(../../fonts/FiraSans-Regular.woff2) format('woff2'),url(../../fonts/FiraSans-Regular.ttf) format('truetype');font-weight:400;font-style:normal;font-display:swap}@font-face{font-family:'Fira Mono';src:url(../../fonts/FiraMono-Regular.eot);src:local('Fira Mono'),url(../../fonts/FiraMono-Regular.eot) format('embedded-opentype'),url(../../fonts/FiraMono-Regular.woff2) format('woff2'),url(../../fonts/FiraMono-Regular.woff) format('woff'),url(../../fonts/FiraMono-Regular.ttf) format('truetype');font-weight:400;font-style:normal;font-display:swap}</style><link rel=stylesheet href=../../css/theme.css><link rel=stylesheet href=../../css/highlight.css></head><body class=font-sans><div class="container mx-auto mt-8"><div class=columns-1><h1 id=file>File</h1><p>Adds file(s) to be extracted to the current output path (<a href=../Variables/OUTDIR.html><code>$OUTDIR</code></a>).</p><ul><li>Note that the output file name is $OUTDIR\filename_portion_of_file.</li><li>Use <code>/oname=X</code> switch to change the output name. X may contain variables and can be a fully qualified path or a relative path in which case it will be appended to <a href=../Variables/OUTDIR.html><code>$OUTDIR</code></a> set by <a href=SetOutPath.html><code>SetOutPath</code></a>. When using this switch, only one file can be specified. If the output name contains spaces, quote the entire parameter, including /oname, as shown in the examples below.</li><li>Wildcards are supported.</li><li>If the <code>/r</code> switch is used, matching files and directories are recursively searched for in subdirectories. If just one path segment is specified (e.g. File /r something), the current directory will be recursively searched. If more than one segment is specified (e.g. File /r something*.*), the last path segment will be used as the matching condition and the rest for the directory to search recursively. If a directory name matches, all of its contents is added recursively. Directory structure is preserved.</li><li>Use the <code>/x</code>switch to exclude files or directories.</li><li>If the <code>/a</code> switch is used, the attributes of the file(s) added will be preserved.</li><li>The <code>File</code> command sets the error flag if overwrite mode is set to &#39;try&#39; and the file could not be overwritten, or if the overwrite mode is set to &#39;on&#39; and the file could not be overwritten and the user selects ignore.</li><li>If the <code>/nonfatal</code> switch is used and no files are found, a warning will be issued instead of an error.</li></ul><h2 id=parameters>Parameters</h2><pre><code class="hljs language-nsis">[/nonfatal] [/a] ([/r] [/x <span class=hljs-keyword>file</span>|wildcard [...]] (<span class=hljs-keyword>file</span>|wildcard) [...] | /oname=<span class=hljs-keyword>file</span>.dat infile.dat)
</code></pre><h2 id=example>Example</h2><pre><code class="hljs language-nsis"><span class=hljs-keyword>File</span> something.exe
<span class=hljs-keyword>File</span> /a something.exe
<span class=hljs-keyword>File</span> *.exe
<span class=hljs-keyword>File</span> /r *.dat
<span class=hljs-keyword>File</span> /r data
<span class=hljs-keyword>File</span> /oname=temp.dat somefile.ext
<span class=hljs-keyword>File</span> /oname=<span class=hljs-variable>$TEMP</span>\temp.dat somefile.ext
<span class=hljs-keyword>File</span> <span class=hljs-string>&quot;/oname=<span class="hljs-variable constant_">$TEMP</span>\name with spaces.dat&quot;</span> somefile.ext
<span class=hljs-keyword>File</span> /nonfatal <span class=hljs-string>&quot;a file that might not exist&quot;</span>
<span class=hljs-keyword>File</span> /r /x CVS myproject\*.*
<span class=hljs-keyword>File</span> /r /x *.res /x *.obj /x *.pch source\*.*
</code></pre><p><strong>Note:</strong> when using the <code>/r</code> switch, both matching directories and files will be searched. This is always done with or without the use of wildcards, even if the given path perfectly matches one directory. That means, the following directory structure:</p><pre><code class="hljs language-nsis">something/
├── <span class=hljs-keyword>file</span>.dat
└── another.dat
dir/
├── something
├── dir2/
│   └── file2.dat
└── another/
    └── something/
        └── readme.txt
</code></pre><p>with the following <code>File</code> usage:</p><pre><code class="hljs language-nsis"><span class=hljs-keyword>File</span> /r something
</code></pre><p>will match the directory named something on the root directory, the file named something in the directory named dir and the directory named something in the directory named another. To match only the directory named something on the root directory, use the following:</p><pre><code class="hljs language-nsis"><span class=hljs-keyword>File</span> /r something\*.*
</code></pre><p>When adding *.*, it will be used as the matching condition and something will be used as the directory to search. When only something is specified, the current directory will be recursively searched for every and directory named something and another\something will be matched.</p><h2 id=history>History</h2><p>Added in NSIS v1.0f</p></div><div class="columns-1 text-right"><hr><a href=https://github.com/NSIS-Dev/Documentation/edit/main/docs/Commands/File.md>Edit on GitHub</a></div></div></body></html>